# Лабораторная №3 на C++

Вариант
```lisp | risc | neum | hw | instr | binary | stream | mem | pstr | prob5 | pipeline```

С усложнением

## Язык программирования

Язык Lisp-подобный, с S-выражениями.
Типизации нет: все выражения целочисленные, 32-битные.

```bnf
program = paren | paren program

paren = "(" expr-list ")"

expr-list = expr | expr expr-list

expr = paren | number | identifier | string-literal
```

Названия правил `number`, `identifier`, `string-literal` говорят сами за себя.

Пользовательских функций нет, распознаются встроенные:

* `if` - условное вычисление одного из двух выражений
* `while` - цикл
* `set` - установить значение переменной
* `alloc-static` - выделить статическую память
* `print-string` - напечатать P-строку
* `read-mem` - прочитать память по адресу
* `write-mem` - записать в память по адресу
* `progn` - последовательное исполнение
* Арифметика: `+`, `-`, `*`, `/`, `%`. Последний - взятие по модулю. `+` и `*` принимают произвольное число аргументов (хотя бы два)
* Сравнения `>`, `<`, `=`

## Компилятор

1. Преобразует текстовый поток в дерево ([1-parse.cpp](./compiler/1-parse.cpp))
2. Обходя дерево в аппликативном порядке, генерирует IR ([2-gen-ir.cpp](./compiler/2-gen-ir.cpp))
3. Раскрашивает значения в IR доступными регистрами ([3-codegen.cpp](./compiler/3-codegen.cpp))
4. Генерирует итоговый поток инструкций, преобразуя "высокоуровневые" IR-операции в инструкции (там же)
5. Формирует финальный образ, готовый к загрузке в память процессора

Заметим, что IR имеет инструкцию MOV между абстрактными переменными, но в ISA её нет.
Компилятор заменяет её инструкциями или последовательностями инструкций в зависимости от
того, отражены абстрактные значения в регистр, в память или в константу.
Например, `r0 <- r1` можно записать в ISA как `add r0 <- r1, 0`.

Похожим образом компилятор разбирает доступные случаи для IR-STORE и IR-LOAD. На одну
"явную" операцию с памятью (которая была запрошена из исходного кода) может прийтись до
трёх операций в итоговом коде.

## Процессор

Регистров 64 по 32 бита. Все регистры равноправны. Флагов нет; инструкция
условного прыжка проверяет заданный (любой) регистр на равенство нулю.

32 бита - минимальная адресуемая единица (т.е. если считать байтом 8
бит, то 0x2 - смещение на 8 байт, а адресуемое пространство - 16 ГиБ).

Адресация существует только абсолютная, что сильно уменьшает размер адресуемого
пространства в некоторых случаях.

Существует 13 инструкций. Во всех инструкциях опкод в младших 4 битах.

* 0, `hlt` - остановить выполнение
* 1/2, `ld`/`st` - обмен словом данных между регистром и памятью. Адрес может браться из регистра или быть вшит в инструкцию (21 бит)
* 3...A - бинарные операции арифметики и сравнения: `add`, `sub`, `mul`, `div`, `mod`, `equ`, `lt`, `gt`.
Принимают два входных значения и регистр-результат. Каждое входное значение может быть регистром
или константой (10 бит).
* B - безусловный переход по адресу. Адрес - константа (28 бит)
* C - условный переход по адресу. Адрес - константа (22 бита), условие - заданный регистр не 0

## Организация памяти

Архитектура фон Неймановская. Данные и код в одном адресном пространстве.

Было решено расположить данные в начале памяти, до кода (это упрощало компилятор).
Поскольку точка входа процессора - адрес 0x0, то этот адрес резервируется под jmp на основной
код.

Адрес MMIO, привязанный к stdin/stdout эмулятора - 0x3. Адреса 0x1 и 0x2 не используются.
Изначально адрес MMIO был 0x1, но это вызвало проблемы с prefetch при пуске процессора: во
время декодирования исходной инструкции jmp процессор пытался спекулятивно прочитать
следующую инструкцию из stdin.

```text
0x0    jmp 0x40 (адрес для примера, зависит от размера данных)
0x1    не используется
0x2    не используется
0x3    MMIO
0x4    ----- начало данных ----
...    данные
0x40   ------ начало кода -----
...    код
```


